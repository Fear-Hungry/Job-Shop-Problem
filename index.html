<!DOCTYPE html>
<html lang="pt-BR" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Análise da Solução para o Job-Shop Problem</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            @apply bg-slate-100 text-slate-700 dark:bg-slate-900 dark:text-slate-300 transition-colors duration-300;
        }
        .mermaid {
            @apply flex justify-center my-8;
        }
        .mermaid svg {
            display: block;
            max-width: 100%;
        }
        /* Adaptação do Mermaid para Dark Mode */
        .dark .mermaid svg text, .dark .mermaid svg .label, .dark .mermaid svg .edgeLabel, .dark .mermaid svg .nodeLabel {
            fill: #cbd5e1 !important; /* Tailwind slate-300 */
        }
        .dark .mermaid svg .node rect, .dark .mermaid svg .node circle, .dark .mermaid svg .node ellipse, .dark .mermaid svg .node polygon, .dark .mermaid svg .node path {
            stroke: #64748b !important; /* Tailwind slate-500 */
            fill: #334155 !important; /* Tailwind slate-700 */
        }
         .dark .mermaid svg .cluster rect {
            stroke: #64748b !important; /* Tailwind slate-500 */
            fill: #475569 !important; /* Tailwind slate-600 */
        }
        .dark .mermaid svg .arrowheadPath {
            fill: #64748b !important; /* Tailwind slate-500 */
        }
        .dark .mermaid svg .edgePath .path {
            stroke: #64748b !important; /* Tailwind slate-500 */
        }

        h2 { /* Títulos principais de secção */
            @apply text-3xl font-extrabold text-sky-600 dark:text-sky-400 mt-0 mb-6;
        }
        h3 { /* Subtítulos dentro das secções */
            @apply text-xl font-bold text-sky-700 dark:text-sky-500 mt-8 mb-4;
        }

        /* Estilos da Tabela Melhorados */
        table {
            @apply w-full mt-6 border-collapse shadow-lg rounded-lg overflow-hidden;
        }
        th, td {
            @apply border border-slate-200 dark:border-slate-700 p-4;
        }
        th {
            @apply bg-slate-100 dark:bg-slate-800 text-sm font-bold text-slate-600 dark:text-slate-300 uppercase tracking-wider;
        }
        td {
            @apply text-sm text-slate-600 dark:text-slate-400;
        }
        /* Alinhamento específico para colunas da tabela */
        .th-instancia, .td-instancia { @apply text-center; }
        .th-makespan, .td-makespan { @apply text-right; }
        .th-tempo, .td-tempo { @apply text-right; }

        /* Zebra striping para linhas da tabela */
        tbody tr:nth-child(even) {
            @apply bg-slate-50 dark:bg-slate-800/60;
        }
        tbody tr:hover {
            @apply bg-sky-50 dark:bg-sky-900/40;
        }


        code { /* Estilo para código inline */
            @apply bg-slate-200 dark:bg-slate-700 text-sky-700 dark:text-sky-400 px-1.5 py-0.5 rounded-md text-sm font-mono;
        }
        .formula-ucb1 { /* Estilo para a fórmula UCB1 */
            @apply bg-slate-100 dark:bg-slate-800 p-4 rounded-lg my-4 text-center text-sm shadow;
        }
        .container-custom {
            max-width: 1024px;
            margin-left: auto;
            margin-right: auto;
        }
        .active-nav-link {
            @apply bg-sky-600 text-white font-semibold shadow-lg;
        }
        html {
            scroll-behavior: smooth;
        }
        .back-to-top {
            @apply block text-sm text-sky-600 dark:text-sky-400 hover:text-sky-700 dark:hover:text-sky-300 mt-8 text-right font-semibold transition-colors duration-150;
        }
        #darkModeToggle {
            @apply p-2 rounded-full hover:bg-sky-400 dark:hover:bg-sky-700 text-white focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-sky-600 dark:focus:ring-offset-sky-500 focus:ring-white transition-colors duration-150;
        }
        #darkModeToggle svg {
            @apply h-5 w-5;
        }
        #sidebar {
            @apply bg-white dark:bg-slate-800/80 backdrop-blur-md border-r border-slate-200 dark:border-slate-700/60 shadow-xl;
        }
        #sidebar h3 {
            @apply text-xs font-bold text-slate-400 dark:text-slate-500 uppercase tracking-wider mt-0 mb-5 px-4;
        }
        #sidebar .nav-link {
            @apply px-4 py-2.5 text-slate-600 dark:text-slate-300 hover:bg-sky-100 dark:hover:bg-slate-700 hover:text-sky-600 dark:hover:text-sky-300 rounded-lg text-sm font-medium transition-all duration-150 ease-in-out transform hover:translate-x-1;
        }
        main section { /* Cartões de secção */
            @apply bg-white dark:bg-slate-800/80 backdrop-blur-md rounded-xl shadow-xl p-6 sm:p-10 border-t-4 border-sky-500 dark:border-sky-600;
        }
        /* Estilo para listas dentro das seções */
        main section ul, main section ol {
            @apply list-outside ml-5 space-y-3 text-slate-600 dark:text-slate-400 text-base md:text-lg leading-relaxed;
        }
        main section ul li strong, main section ol li strong {
            @apply font-semibold text-slate-700 dark:text-slate-200;
        }
        main section ul ul, main section ol ol {
            @apply mt-2 ml-5 space-y-2;
        }
        main section ul ul li strong, main section ol ol li strong {
            @apply font-medium;
        }
        main section ul { @apply list-disc; }
        main section ul ul { @apply list-circle; }
        main section ol { @apply list-decimal; }

    </style>
</head>
<body class="leading-relaxed">

    <header id="page-header" class="fixed top-0 left-0 right-0 z-30 bg-gradient-to-r from-sky-600 to-indigo-700 text-white shadow-lg h-16 flex items-center justify-between px-4 sm:px-6">
        <div class="container-custom flex items-center justify-between w-full">
            <h1 class="text-xl sm:text-2xl font-extrabold tracking-tight">Análise da Solução para o Job-Shop Problem</h1>
            <button id="darkModeToggle" aria-label="Alternar modo claro/escuro">
                <svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="h-5 w-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-6.364-.386l1.591-1.591M3 12h2.25m.386-6.364l1.591 1.591" />
                </svg>
                <svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="h-5 w-5 hidden">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21c1.603 0 3.113-.337 4.5-1.002z" />
                </svg>
            </button>
        </div>
    </header>

    <aside id="sidebar" class="fixed top-16 left-0 w-64 h-[calc(100vh-4rem)] p-6 z-20 transition-colors duration-300">
        <h3>Navegação</h3>
        <nav class="mt-2">
            <ul class="space-y-2">
                <li><a href="#intro-jssp" aria-label="Ir para a seção Introdução ao JSSP" class="nav-link">Introdução JSSP</a></li>
                <li><a href="#abordagem-algoritmos" aria-label="Ir para a seção Abordagem e Solvers" class="nav-link">Abordagem e Solvers</a></li>
                <li><a href="#fluxograma" aria-label="Ir para a seção Fluxograma" class="nav-link">Fluxograma</a></li>
                <li><a href="#resultados" aria-label="Ir para a seção Resultados" class="nav-link">Resultados</a></li>
                <li><a href="#conclusao" aria-label="Ir para a seção Conclusão" class="nav-link">Conclusão</a></li>
            </ul>
        </nav>
    </aside>

    <div class="pt-16 pl-0 md:pl-64 min-h-screen flex flex-col">
        <main class="flex-grow container-custom px-4 sm:px-6 py-10">
            <section id="intro-jssp" class="scroll-mt-20 mb-10 p-6 sm:p-10">
                <h2>Introdução ao Problema Job-Shop (JSSP)</h2>
                <p class="mt-4 text-slate-600 dark:text-slate-400 text-base md:text-lg leading-relaxed">O Problema de Escalonamento Job-Shop (JSSP) é um dos problemas de otimização combinatória mais conhecidos e desafiadores na área de pesquisa operacional e ciência da computação. O objetivo principal é determinar a sequência ótima de operações para um conjunto de trabalhos (jobs) que devem ser processados em um conjunto de máquinas, minimizando geralmente o tempo total para completar todos os trabalhos (makespan).</p>
                <p class="mt-4 text-slate-600 dark:text-slate-400 text-base md:text-lg leading-relaxed">Este documento apresenta uma análise aprofundada dos componentes algorítmicos e da arquitetura da solução desenvolvida para o JSSP, com foco nas técnicas de resolução empregadas.</p>
                <a href="#page-header" class="back-to-top" aria-label="Voltar ao topo da página">Voltar ao Topo &uarr;</a>
            </section>

            <section id="abordagem-algoritmos" class="scroll-mt-20 mb-10 p-6 sm:p-10">
                <h2>Abordagem da Solução e Algoritmos de Solver</h2>
                <p class="mt-4 text-slate-600 dark:text-slate-400 text-base md:text-lg leading-relaxed">
                    A solução implementada (conforme código no diretório <code>src/</code>) é estruturada em torno de componentes modulares que encapsulam diferentes aspectos do tratamento do JSSP, com ênfase nos algoritmos de otimização.
                </p>

                <h3 id="solver-cp-sat">Geração da Solução Inicial (CP-SAT)</h3>
                <p class="mt-3 text-slate-600 dark:text-slate-400 text-base md:text-lg leading-relaxed">
                    Para acelerar a convergência e fornecer um ponto de partida de alta qualidade, a solução integra um solver baseado em Programação por Restrições (CP-SAT), utilizando a biblioteca OR-Tools. Uma porção configurável do tempo total de resolução pode ser alocada para que o solver CP-SAT tente encontrar uma solução ótima ou de boa qualidade. O cronograma resultante desta fase é então utilizado como semente para a população inicial do Algoritmo Genético.
                </p>

                <h3 id="solver-ga">Otimização por Algoritmo Genético (GA)</h3>
                <p class="mt-3 text-slate-600 dark:text-slate-400 text-base md:text-lg leading-relaxed">
                    O componente central da busca heurística é um Algoritmo Genético (GA) projetado para explorar eficientemente o espaço de soluções do JSSP, com o objetivo primário de minimizar o makespan.
                </p>
                <ul class="mt-4">
                    <li>
                        <p class="mb-1"><strong>Gene e Cromossomo (Codificação da Solução):</strong> Cada gene é uma tupla <code>(job_id, op_id)</code>, identificando unicamente uma operação (qual trabalho e qual etapa desse trabalho). O cromossomo é uma lista/array dessas tuplas, contendo todas as operações numa ordem específica. Essa ordem determina a sequência em que se tenta agendar cada operação, garantindo que, para cada job, suas operações apareçam na ordem correta de precedência.</p>
                    </li>
                    <li>
                        <p class="mb-1"><strong>Inicialização da População:</strong> Geramos a população inicial usando:</p>
                        <ul class="mt-2">
                            <li>Solução CP-SAT já decodificada em cromossomo (extraindo a sequência de <code>(job_id, op_id)</code>).</li>
                            <li>Heurísticas como SPT, LPT e FIFO que retornam diretamente um cromossomo válido.</li>
                            <li>Preenchimento aleatório ou “shuffles” leves dessas sementes, garantindo que cada cromossomo tenha todas as operações exatamente uma vez.</li>
                        </ul>
                    </li>
                    <li>
                        <p class="mb-1"><strong>Decodificação e Avaliação da Qualidade (Fitness):</strong> Para avaliar um cromossomo, a função <code>_calculate_schedule_details_static</code> percorre a lista de genes na ordem dada. Coloca cada operação em seu início mais cedo possível (respeitando precedência interna do job e disponibilidade da máquina) e retorna um makespan. Esse makespan é a fitness (menor é melhor).</p>
                    </li>
                    <li>
                        <p class="mb-1"><strong>Mecanismo de Seleção de Pais:</strong> Para selecionar os indivíduos que participarão da reprodução, o GA emprega predominantemente a <strong>seleção por torneio binário</strong>. Adicionalmente, uma estratégia de <strong>elitismo</strong> é implementada, garantindo que uma certa quantidade dos melhores indivíduos de uma geração seja transferida diretamente para a próxima.</p>
                    </li>
                    <li>
                        <p class="mb-1"><strong>Operadores Genéticos (Cruzamento e Mutação):</strong></p>
                        <ul class="mt-2">
                            <li><strong>Cruzamento (Recombinação):</strong> São variantes de operadores de permutação (PMX, Order Crossover, Position-Based, DisjunctiveCrossover, etc.), que trocam ou reordenam genes sem quebrar a “permutação completa”. O <strong>DisjunctiveCrossover</strong> é adaptado para o JSSP, combinando sequências de operações por máquina dos pais.</li>
                            <li><strong>Mutação:</strong> Para introduzir diversidade, são usados operadores como a troca simples (StandardMutation), a <strong>DisjunctiveMutation</strong> (atua numa máquina específica) e a <strong>CriticalPathSwap</strong> (foca em otimizar o caminho crítico).</li>
                            <li>Opcionalmente, soluções geradas por cruzamento ou mutação podem passar por busca local (algoritmos meméticos).</li>
                        </ul>
                    </li>
                    <li>
                        <p class="mb-1"><strong>Integração da Busca Local no Fluxo do GA:</strong> A busca local é integrada de duas formas principais:</p>
                        <ol class="mt-2">
                            <li>Como parte de um algoritmo memético (aplicada a novos indivíduos).</li>
                            <li>Como uma fase de intensificação final (aplicada à melhor solução do GA).</li>
                        </ol>
                    </li>
                    <li>
                        <p class="mb-1"><strong>Gestão da População:</strong> Ao final de cada geração, a nova população é formada pelos descendentes e pelos indivíduos preservados pelo elitismo.</p>
                    </li>
                </ul>
                <p class="mt-4 text-slate-600 dark:text-slate-400 text-base md:text-lg leading-relaxed">
                    Em suma, codificamos o problema de Job-Shop como uma simples permutação de genes <code>(job, etapa)</code>. A validação de precedência e cálculo de makespan ficam a cargo do decodificador estático, e todos os operadores genéticos trabalham sobre essa representação de permutação.
                </p>

                <h3 id="solver-ucb1">Seleção Adaptativa de Operadores Genéticos (UCB1)</h3>
                <p class="mt-3 text-slate-600 dark:text-slate-400 text-base md:text-lg leading-relaxed">
                    Para otimizar a aplicação dos diversos operadores genéticos (crossover e mutação) disponíveis, foi implementado um mecanismo de seleção adaptativa baseado no algoritmo UCB1 (Upper Confidence Bound). Este algoritmo busca um equilíbrio entre "exploração" (tentar operadores menos utilizados) e "aproveitamento" (utilizar operadores com bom desempenho histórico). A recompensa de um operador reflete sua capacidade de gerar soluções melhores, e as probabilidades de seleção são atualizadas dinamicamente.
                </p>
                <div class="formula-ucb1">
                    <code class="text-lg">score<sub>i</sub> = R&#773;<sub>i</sub> + c &radic;( (ln N) / n<sub>i</sub> )</code>
                </div>

                <h3 id="solver-grafos">Representação e Manipulação baseada em Grafos</h3>
                 <ul class="mt-3">
                    <li>Implementação do <strong>Grafo Disjuntivo</strong> do JSSP, uma estrutura de dados fundamental para representar as restrições de precedência e de máquina. Este grafo é usado para detectar ciclos (inviabilidades), obter a ordenação topológica das operações e calcular o makespan (caminho crítico) de um cronograma.</li>
                    <li>Utilização da estrutura Union-Find (Disjoint Set Union) como auxiliar na detecção eficiente de ciclos durante a construção ou modificação de soluções.</li>
                </ul>


                <h3 id="solver-vnd">Refinamento por Busca Local (Estratégias de Vizinhança - VND)</h3>
                <p class="mt-3 text-slate-600 dark:text-slate-400 text-base md:text-lg leading-relaxed">
                    Para intensificar a busca e refinar as soluções promissoras, é empregada a Variable Neighborhood Descent (VND). A VND explora sistematicamente múltiplas estruturas de vizinhança (tipos de movimentos).
                </p>
                <ul class="mt-3">
                    <li>O principal método é a <strong>Variable Neighborhood Descent (VND)</strong>, que explora sistematicamente múltiplas estruturas de vizinhança. Contempla uma possível orquestração adaptativa da ordem e seleção das vizinhanças, potencialmente utilizando UCB1.</li>
                    <li>Um conjunto de <strong>operadores de vizinhança</strong> (movimentos) que podem ser aplicados a uma solução. Estes incluem trocas simples (Swap), inversão de segmentos (Inversion), embaralhamento de segmentos (Scramble), movimentos do tipo 2-opt e 3-opt, movimentação de blocos de operações (BlockMove) e troca de blocos (BlockSwap).</li>
                </ul>
                <a href="#page-header" class="back-to-top" aria-label="Voltar ao topo da página">Voltar ao Topo &uarr;</a>
            </section>

            <section id="fluxograma" class="scroll-mt-20 mb-10 p-6 sm:p-10">
                <h2>Fluxograma Geral do Processo de Solução</h2>
                <p class="mt-4 mb-3 text-slate-600 dark:text-slate-400 text-base md:text-lg leading-relaxed">O diagrama abaixo ilustra o fluxo principal:</p>
                <div class="mermaid">
flowchart TD
    A["Leitura da Instância"] --> B{"Solver CP-SAT?"};
    B -- "Sim" --> C["Solução CP-SAT"];
    B -- "Não/Timeout" --> D["Heurísticas Construtivas"];
    C --> E["População Inicial GA"];
    D --> E;
    E --> F["Algoritmo Genético"];
    F -- "Seleção Adaptativa (UCB1)" --> F;
    F --> G{"Aplicar Busca Local?"};
    G -- "Sim" --> H["Busca Local (VND)"];
    G -- "Não" --> I["Solução Refinada"];
    H --> I;
    I --> J["Solução Final e Validação"];
                </div>
                <a href="#page-header" class="back-to-top" aria-label="Voltar ao topo da página">Voltar ao Topo &uarr;</a>
            </section>

            <section id="resultados" class="scroll-mt-20 mb-10 p-6 sm:p-10">
                <h2>Resultados Obtidos</h2>
                <p class="mt-4 text-slate-600 dark:text-slate-400 text-base md:text-lg leading-relaxed">
                    A abordagem proposta foi avaliada em diversas instâncias benchmark do Job-Shop Scheduling Problem, amplamente utilizadas na literatura. A tabela a seguir apresenta o makespan final alcançado e o tempo total de execução para cada instância:
                </p>
                <div class="overflow-x-auto mt-6">
                    <table>
                        <thead>
                            <tr>
                                <th class="th-instancia">Instância</th>
                                <th class="th-makespan">Melhor Makespan Final</th>
                                <th class="th-tempo">Tempo Total de Execução</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td class="td-instancia">abz5</td><td class="td-makespan">1266</td><td class="td-tempo">48,33 s</td></tr>
                            <tr><td class="td-instancia">abz6</td><td class="td-makespan">977</td><td class="td-tempo">25,56 s</td></tr>
                            <tr><td class="td-instancia">abz7</td><td class="td-makespan">701</td><td class="td-tempo">382,54 s</td></tr>
                            <tr><td class="td-instancia">abz8</td><td class="td-makespan">993</td><td class="td-tempo">33,39 s</td></tr>
                            <tr><td class="td-instancia">abz9</td><td class="td-makespan">747</td><td class="td-tempo">206,45 s</td></tr>
                            <tr><td class="td-instancia">la01</td><td class="td-makespan">666</td><td class="td-tempo">15,52 s</td></tr>
                            <tr><td class="td-instancia">la02</td><td class="td-makespan">672</td><td class="td-tempo">28,08 s</td></tr>
                            <tr><td class="td-instancia">la03</td><td class="td-makespan">606</td><td class="td-tempo">21,63 s</td></tr>
                            <tr><td class="td-instancia">la04</td><td class="td-makespan">611</td><td class="td-tempo">16,29 s</td></tr>
                            <tr><td class="td-instancia">la05</td><td class="td-makespan">593</td><td class="td-tempo">15,45 s</td></tr>
                            <tr><td class="td-instancia">la06</td><td class="td-makespan">926</td><td class="td-tempo">28,89 s</td></tr>
                            <tr><td class="td-instancia">la07</td><td class="td-makespan">890</td><td class="td-tempo">24,76 s</td></tr>
                            <tr><td class="td-instancia">la08</td><td class="td-makespan">863</td><td class="td-tempo">23,77 s</td></tr>
                        </tbody>
                    </table>
                </div>
                <p class="mt-6 text-slate-600 dark:text-slate-400 text-base md:text-lg leading-relaxed">
                    Observa-se que a abordagem foi capaz de encontrar soluções de alta qualidade para todas as instâncias, mantendo tempos de execução competitivos mesmo em casos de maior complexidade.
                </p>
                <p class="mt-4 text-slate-600 dark:text-slate-400 text-base md:text-lg leading-relaxed">
                    Esses resultados reforçam que a estratégia adotada — combinando um Algoritmo Genético robusto, soluções iniciais via CP-SAT, seleção adaptativa de operadores e busca local intensiva — é promissora para enfrentar a complexidade do JSSP, apresentando desempenho competitivo frente aos benchmarks clássicos do problema.
                </p>
                <a href="#page-header" class="back-to-top" aria-label="Voltar ao topo da página">Voltar ao Topo &uarr;</a>
            </section>

            <section id="conclusao" class="scroll-mt-20 mb-10 p-6 sm:p-10">
                <h2>Conclusão e Principais Destaques</h2>
                <p class="mt-4 text-slate-600 dark:text-slate-400 text-base md:text-lg leading-relaxed">A solução apresentada demonstra uma abordagem híbrida e robusta para o Problema de Escalonamento Job-Shop, combinando a precisão de solvers exatos para soluções iniciais com a capacidade de exploração e refinamento de meta-heurísticas avançadas. Os principais destaques incluem:</p>
                <ul class="list-disc list-inside mt-6 space-y-3 text-slate-600 dark:text-slate-400 text-base md:text-lg">
                    <li><strong>Geração de Soluções Iniciais de Qualidade:</strong> Utilização do CP-SAT para fornecer um ponto de partida sólido.</li>
                    <li><strong>Algoritmo Genético Especializado:</strong> Com codificação, operadores de cruzamento e mutação adaptados ao JSSP.</li>
                    <li><strong>Seleção Adaptativa de Operadores (UCB1):</strong> Otimização dinâmica da escolha dos operadores genéticos.</li>
                    <li><strong>Manipulação Eficiente de Restrições:</strong> Uso do Grafo Disjuntivo para cálculo de makespan e validação.</li>
                    <li><strong>Busca Local Intensiva (VND):</strong> Para refinamento eficaz das soluções encontradas.</li>
                </ul>
                <p class="mt-4 text-slate-600 dark:text-slate-400 text-base md:text-lg leading-relaxed">Esta combinação de técnicas visa um equilíbrio eficaz entre exploração global e exploração local, resultando numa ferramenta poderosa para encontrar cronogramas de baixo makespan.</p>
                <a href="#page-header" class="back-to-top" aria-label="Voltar ao topo da página">Voltar ao Topo &uarr;</a>
            </section>
        </main>

        <footer class="bg-slate-100 dark:bg-slate-900 border-t border-slate-200 dark:border-slate-700/60 text-slate-500 dark:text-slate-400 py-12 text-center transition-colors duration-300">
            <div class="container-custom px-6">
                <p class="text-sm">&copy; <span id="currentYear"></span> Seu Nome/Nome do Projeto. Todos os direitos reservados.</p>
                <p class="mt-2 text-xs">Página de demonstração do trabalho sobre JSSP.</p>
            </div>
        </footer>
    </div>

    <script>
        document.getElementById('currentYear').textContent = new Date().getFullYear();

        const darkModeToggle = document.getElementById('darkModeToggle');
        const sunIcon = document.getElementById('sunIcon');
        const moonIcon = document.getElementById('moonIcon');
        const htmlElement = document.documentElement;

        function applyTheme(isDark) {
            if (isDark) {
                htmlElement.classList.add('dark');
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
                localStorage.setItem('theme', 'dark');
            } else {
                htmlElement.classList.remove('dark');
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
                localStorage.setItem('theme', 'light');
            }

            if (typeof mermaid !== 'undefined') {
                document.querySelectorAll('.mermaid').forEach(el => {
                    const originalGraphDefinition = el.getAttribute('data-original-definition');
                    if (originalGraphDefinition) {
                        el.removeAttribute('data-processed');
                        el.innerHTML = '';

                        const themeDirective = `%%{init: {'theme': '${isDark ? 'dark' : 'neutral'}'}}%%\n`;
                        const definitionTextNode = document.createTextNode(themeDirective + originalGraphDefinition);
                        el.appendChild(definitionTextNode);
                    }
                });
                try {
                    // Use a more targeted run if possible, or ensure elements are ready
                     const nodesToRun = Array.from(document.querySelectorAll('.mermaid')).filter(el => el.getAttribute('data-original-definition'));
                    if (nodesToRun.length > 0) {
                         mermaid.run({nodes: nodesToRun});
                    }
                } catch (e) {
                    console.error("Erro ao re-renderizar Mermaid:", e);
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.mermaid').forEach(el => {
                const rawDefinition = Array.from(el.childNodes)
                                        .filter(node => node.nodeType === Node.TEXT_NODE)
                                        .map(node => node.nodeValue)
                                        .join('\n')
                                        .trim();
                if (rawDefinition) {
                    el.setAttribute('data-original-definition', rawDefinition);
                }
                el.innerHTML = '';
            });

            if (typeof mermaid !== 'undefined') {
                try {
                    mermaid.initialize({ startOnLoad: false });
                } catch (e) {
                    console.error("Erro ao inicializar Mermaid:", e);
                }
            }

            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            let initialIsDark = prefersDark;
            if (savedTheme) {
                initialIsDark = (savedTheme === 'dark');
            }

            // Apply class to HTML element first for immediate visual feedback
            if (initialIsDark) {
                htmlElement.classList.add('dark');
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
            } else {
                htmlElement.classList.remove('dark');
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
            }
            // Then call applyTheme to handle localStorage and Mermaid rendering
            applyTheme(initialIsDark);

            onScrollSpy();
        });

        darkModeToggle.addEventListener('click', () => {
            applyTheme(!htmlElement.classList.contains('dark'));
        });

        const sections = document.querySelectorAll('main section[id]');
        const navLinks = document.querySelectorAll('#sidebar nav a.nav-link');
        const headerHeight = document.getElementById('page-header')?.offsetHeight || 64;
        const scrollSpyOffset = headerHeight + 24;
        const activeLinkClass = 'active-nav-link';

        function onScrollSpy() {
            const currentScroll = window.pageYOffset;
            let currentSectionId = "";

            sections.forEach(section => {
                const sectionTop = section.offsetTop - scrollSpyOffset;
                if (currentScroll >= sectionTop) {
                    currentSectionId = section.id;
                }
            });

            if ((window.innerHeight + currentScroll + 10) >= document.body.offsetHeight) {
                 if (sections.length > 0) currentSectionId = sections[sections.length - 1].id;
            } else if (sections.length > 0 && currentScroll < (sections[0].offsetTop - scrollSpyOffset)) {
                 currentSectionId = "";
            }

            navLinks.forEach(link => {
                link.classList.remove(activeLinkClass);
                if (link.hash === `#${currentSectionId}`) {
                    link.classList.add(activeLinkClass);
                }
            });
        }
        window.addEventListener('scroll', onScrollSpy);

    </script>

</body>
</html>
