<!DOCTYPE html>
<html lang="pt-BR" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Análise da Solução para o Job-Shop Problem</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script> 
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" xintegrity="sha384-n8MVd4RsNIU07RLA8HuZQLoRtfFUyFDRVdN/LEqBqwZPmz9HiVlLqCOQD97ZYzXz" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" xintegrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" xintegrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            @apply bg-slate-100 text-slate-700 dark:bg-slate-900 dark:text-slate-300 transition-colors duration-300;
        }
        .mermaid {
            @apply flex justify-center my-8; 
        }
        .mermaid svg {
            display: block; 
            max-width: 100%;
            height: auto; 
        }
        .dark .mermaid svg text, .dark .mermaid svg .label, .dark .mermaid svg .edgeLabel, .dark .mermaid svg .nodeLabel, .dark .mermaid svg .labelText, .dark .mermaid svg tspan {
            fill: #cbd5e1 !important; 
        }
        .mermaid svg text, .mermaid svg .label, .mermaid svg .edgeLabel, .mermaid svg .nodeLabel, .mermaid svg .labelText, .mermaid svg tspan {
            font-family: 'Inter', sans-serif !important;
        }
        .dark .mermaid svg .node rect, .dark .mermaid svg .node circle, .dark .mermaid svg .node ellipse, .dark .mermaid svg .node polygon, .dark .mermaid svg .node path {
            stroke: #64748b !important; 
            fill: #334155 !important; 
        }
         .dark .mermaid svg .cluster rect {
            stroke: #64748b !important; 
            fill: #475569 !important; 
        }
        .dark .mermaid svg .arrowheadPath {
            fill: #64748b !important; 
        }
        .dark .mermaid svg .edgePath .path {
            stroke: #64748b !important; 
        }

        h2 { 
            @apply text-3xl font-extrabold text-sky-600 dark:text-sky-400 mt-0 mb-6; 
        }
        h3 { 
            @apply text-xl font-bold text-sky-700 dark:text-sky-500 mt-8 mb-4; 
        }
        /* Estilos para HTML renderizado a partir de Markdown */
        .rendered-markdown-content p {
            @apply mt-4 text-slate-600 dark:text-slate-400 text-base md:text-lg leading-relaxed;
        }
        .rendered-markdown-content p:first-child {
            @apply mt-0; 
        }
        .rendered-markdown-content ul, .rendered-markdown-content ol {
            @apply list-outside ml-5 space-y-2 text-slate-600 dark:text-slate-400 text-base md:text-lg leading-relaxed mt-4; 
        }
        .rendered-markdown-content ul { @apply list-disc; }
        .rendered-markdown-content ol { @apply list-decimal; }
        .rendered-markdown-content ul ul, .rendered-markdown-content ol ol {
            @apply mt-1 ml-5 space-y-1; 
        }
        .rendered-markdown-content ul ul { @apply list-circle; }
        .rendered-markdown-content li strong {
            @apply font-semibold text-slate-700 dark:text-slate-200;
        }
        .rendered-markdown-content h3 { 
             @apply text-2xl font-bold text-sky-700 dark:text-sky-500 mt-10 mb-5 border-b border-slate-300 dark:border-slate-700 pb-2;
        }
        .rendered-markdown-content h4 { 
             @apply text-xl font-semibold text-sky-600 dark:text-sky-400 mt-8 mb-3;
        }
         .rendered-markdown-content h5 { 
             @apply text-lg font-semibold text-slate-700 dark:text-slate-300 mt-6 mb-2;
        }
        .rendered-markdown-content code { 
            @apply bg-slate-200 dark:bg-slate-700 text-sky-700 dark:text-sky-400 px-1.5 py-0.5 rounded-md text-sm font-mono;
        }
        .katex-display { 
            @apply my-4 text-lg text-center; 
        }
        .katex { 
            @apply text-base md:text-lg; 
        }
        
        table {
            @apply w-full mt-6 border-collapse shadow-lg rounded-lg overflow-hidden; 
        }
        th, td {
            @apply border border-slate-200 dark:border-slate-700 p-4; 
        }
        th {
            @apply bg-slate-100 dark:bg-slate-800 text-sm font-bold text-slate-600 dark:text-slate-300 uppercase tracking-wider; 
        }
        td {
            @apply text-sm text-slate-600 dark:text-slate-400;
        }
        .th-instancia, .td-instancia { @apply text-center; }
        .th-makespan, .td-makespan { @apply text-right; }
        .th-tempo, .td-tempo { @apply text-right; }
        tbody tr:nth-child(even) {
            @apply bg-slate-50 dark:bg-slate-800/60;
        }
        tbody tr:hover {
            @apply bg-sky-50 dark:bg-sky-900/40; 
        }
        
        .container-custom {
            max-width: 1024px; 
            margin-left: auto;
            margin-right: auto;
        }
        .active-nav-link { 
            @apply bg-sky-500 text-white font-semibold shadow-sm; 
        }
        html {
            /* scroll-behavior: smooth; */
        }
        .back-to-top {
            @apply block text-sm text-sky-600 dark:text-sky-400 hover:text-sky-700 dark:hover:text-sky-300 mt-8 text-right font-semibold transition-colors duration-150;
        }
        #darkModeToggle {
            @apply p-2 rounded-full hover:bg-sky-400 dark:hover:bg-sky-700 text-white focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-sky-600 dark:focus:ring-offset-sky-500 focus:ring-white transition-colors duration-150;
        }
        #darkModeToggle svg {
            @apply h-5 w-5;
        }

        #sidebar {
            @apply bg-slate-200 dark:bg-slate-800 border-r border-slate-300 dark:border-slate-700 shadow-lg; 
        }
        #sidebar h3 { 
            @apply text-sm font-semibold text-slate-500 dark:text-slate-400 uppercase tracking-wider mt-0 mb-5 px-4 pt-1; 
        }
        #sidebar .nav-link { 
            @apply px-4 py-2 text-slate-700 dark:text-slate-300 hover:bg-slate-300 dark:hover:bg-slate-700 hover:text-sky-700 dark:hover:text-sky-400 rounded-md text-sm font-medium transition-colors duration-150 cursor-pointer; 
        }
        
        main section { 
            @apply bg-white dark:bg-slate-800 rounded-xl shadow-xl p-6 sm:p-10 border-t-4 border-sky-500 dark:border-sky-600; 
        }

    </style>
</head>
<body class="leading-relaxed">

    <header id="page-header" class="fixed top-0 left-0 right-0 z-30 bg-gradient-to-r from-sky-600 to-indigo-700 text-white shadow-lg h-16 flex items-center justify-between px-4 sm:px-6">
        <div class="container-custom flex items-center justify-between w-full">
            <h1 class="text-xl sm:text-2xl font-extrabold tracking-tight">Análise da Solução para o Job-Shop Problem</h1>
            <button id="darkModeToggle" aria-label="Alternar modo claro/escuro">
                <svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="h-5 w-5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-6.364-.386l1.591-1.591M3 12h2.25m.386-6.364l1.591 1.591" />
                </svg>
                <svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="h-5 w-5 hidden">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21c1.603 0 3.113-.337 4.5-1.002z" />
                </svg>
            </button>
        </div>
    </header>

    <aside id="sidebar" class="fixed top-16 left-0 w-64 h-[calc(100vh-4rem)] p-6 z-20 transition-colors duration-300"> 
        <h3>Navegação</h3>
        <nav class="mt-2"> 
            <ul class="space-y-2"> 
                <li><a href="#intro-jssp" aria-label="Ir para a seção Introdução ao JSSP" class="nav-link">Introdução JSSP</a></li>
                <li><a href="#abordagem-algoritmos" aria-label="Ir para a seção Abordagem e Solvers" class="nav-link">Abordagem e Solvers</a></li>
                <li><a href="#exemplo-grafo-disjuntivo" aria-label="Ir para a seção Exemplo de Grafo Disjuntivo" class="nav-link">Exemplo Grafo Disjuntivo</a></li>
                <li><a href="#fluxograma" aria-label="Ir para a seção Fluxograma" class="nav-link">Fluxograma</a></li>
                <li><a href="#resultados" aria-label="Ir para a seção Resultados" class="nav-link">Resultados</a></li>
                <li><a href="#conclusao" aria-label="Ir para a seção Conclusão" class="nav-link">Conclusão</a></li>
                <li><a href="#limitacoes-futuros" aria-label="Ir para a seção Limitações e Trabalhos Futuros" class="nav-link">Limitações e Futuro</a></li>
            </ul>
        </nav>
    </aside>

    <div class="pt-16 pl-0 md:pl-64 min-h-screen flex flex-col"> 
        <main class="flex-grow container-custom px-4 sm:px-6 py-10">
            <section id="intro-jssp" class="main-section scroll-mt-20 mb-10 p-6 sm:p-10" style="display: none;">
                <h2>Introdução ao Problema Job-Shop (JSSP)</h2>
                <div class="markdown-source" style="display:none;">
O Problema de Escalonamento Job-Shop (JSSP) é um dos problemas de otimização combinatória mais conhecidos e desafiadores na área de pesquisa operacional e ciência da computação. O objetivo principal é determinar a sequência ótima de operações para um conjunto de trabalhos (jobs) que devem ser processados em um conjunto de máquinas, minimizando geralmente o tempo total para completar todos os trabalhos (makespan).

Este documento apresenta uma análise aprofundada dos componentes algorítmicos e da arquitetura da solução desenvolvida para o JSSP, com foco nas técnicas de resolução empregadas.
                </div>
                <div class="rendered-markdown-content mt-4"></div>
                <a href="#page-header" class="back-to-top" aria-label="Voltar ao topo da página">Voltar ao Topo &uarr;</a>
            </section>

            <section id="abordagem-algoritmos" class="main-section scroll-mt-20 mb-10 p-6 sm:p-10" style="display: none;">
                <h2>Abordagem da Solução e Algoritmos</h2>
                <div class="markdown-source" style="display:none;">
A implementação para resolução do Problema de Escalonamento Job Shop (JSSP) no arquivo `src/main.py` e seus respectivos módulos segue uma abordagem híbrida, combinando métodos exatos e metaheurísticos para buscar soluções de alta qualidade de forma eficiente. O fluxo principal integra:

* Solver Exato (CP-SAT/OR-Tools) para obter uma solução inicial robusta.
* Algoritmo Genético (GA) para exploração intensiva do espaço de soluções e refinamento heurístico.
* Busca Local (Variable Neighborhood Descent - VND) para intensificação e polimento final.

### Fluxo Principal da Solução
O pipeline de solução em `src/main.py` é dividido nas seguintes etapas principais:

1.  **Leitura da Instância**
    Os dados do problema JSSP são lidos de um arquivo de entrada através da função `read_jobshop_instance` (em `src.common`), que converte as informações em listas de jobs, cada um contendo suas operações, máquinas e durações.
2.  **Solução Inicial com CP-SAT**
    Um solver exato (implementado em `ORToolsCPSATSolver`) utiliza o Google OR-Tools para gerar uma solução inicial dentro de um tempo limite (geralmente 10% do tempo total disponível).
    O resultado é um objeto `Schedule`, com as operações ordenadas e os horários de início atribuídos de modo ótimo ou quase ótimo.
    O makespan (tempo total de conclusão) dessa solução é calculado e registrado.
3.  **Otimização Heurística com Algoritmo Genético (GA)**
    Se houver tempo suficiente, o `GeneticSolver` é instanciado, utilizando a solução do CP-SAT como semente da população.
    A população inicial é composta por:
    * A solução do CP-SAT.
    * Soluções heurísticas como SPT (Shortest Processing Time), LPT (Longest Processing Time) e FIFO.
    * Permutações e variações aleatórias para garantir diversidade.
    O GA executa por até 80% do tempo restante, aplicando operadores de crossover, mutação e busca local em cada geração.
    A seleção é feita via torneio binário e elitismo.
    O melhor cromossomo gerado é decodificado em um novo `Schedule`.
    Caso essa solução seja superior à inicial, ela passa a ser a solução corrente.
4.  **Busca Local Final (VND)**
    Se ainda houver tempo, o `VNDLocalSearch` é aplicado ao melhor cromossomo encontrado.
    O VND explora sistematicamente várias vizinhanças (swap, inversion, 2-opt, 3-opt, movimentos de bloco, operadores no caminho crítico, entre outros).
    A função de fitness utilizada é `_calculate_makespan_static`, garantindo que o objetivo do VND seja sempre a redução do makespan.
    Se o VND encontrar uma solução melhor, o cromossomo é decodificado e atualizado.
5.  **Saída dos Resultados**
    Ao final do processo, a melhor solução encontrada é salva no arquivo de saída via `write_output`, no formato esperado pelo problema.

### Pacotes e Módulos Envolvidos

#### 1. `src.common`
* Funções para leitura (`read_jobshop_instance`) e escrita de instâncias/soluções (`write_output`).
* Utilidades para cálculo eficiente de agendamento e makespan (`_calculate_schedule_details_static`, `_calculate_makespan_static`).

#### 2. `src.models`
* Define a classe `Schedule`, responsável por armazenar operações agendadas, permitir ordenação e cálculo do makespan.

#### 3. `src.solver`
* Ponto de entrada abstrato, permite instanciar solvers específicos (CP-SAT ou GA).
* Inclui métodos para validação e obtenção do makespan (`ScheduleValidator`).

#### 4. `src.solvers`
* Implementa os algoritmos de resolução:
    * `ortools_cpsat_solver.py`: modelagem CP do JSSP e uso do OR-Tools.
    * `genetic_solver.py`: núcleo do Algoritmo Genético, detalhado abaixo.
    * Outros arquivos para experimentação (e.g., `bayesopt`, `PBT`).

#### 5. `src.ga` (Componentes do Algoritmo Genético)
* **Inicialização da População:** Usa heurísticas e a solução exata como base inicial, complementando com variações aleatórias para maximizar diversidade.
* **Representação:** Cromossomos são permutações das operações (`job_id`, `op_id`).
* **Fitness:** Calculado via `_calculate_makespan_static`.
* **Seleção:** Implementada por torneio binário, mantendo também elitismo.
* **Operadores Genéticos:**
    * **Crossover:** `OrderCrossover`, `PMX`, `CycleCrossover`, `PositionBasedCrossover`, `DisjunctiveCrossover` (específico para JSSP).
    * **Mutação:** `StandardMutation`, `DisjunctiveMutation`, `CriticalPathSwap`.
    * Os operadores podem ser escolhidos adaptativamente (bandit/roleta) com base no desempenho.
* **Grafo Disjuntivo:** Representa precedências e restrições de máquina. Permite calcular makespan e identificar caminhos críticos de forma eficiente.
* **Diversidade:** Monitoramento constante para ajuste dinâmico das taxas de crossover/mutação e reinserção de diversidade se necessário.

#### 6. `src.local_search` (Busca Local/VND)
* Implementa a estratégia VND e operadores de vizinhança (swap, block move, critical path, LNS).
* Permite o uso de orquestradores adaptativos (UCB1, Gradient Bandit) para seleção dos operadores mais eficazes.
* Usa utilitários para cálculo de makespan e caminho crítico.

#### 7. `src.validators`
* Garante a factibilidade das soluções (sem sobreposição de máquina, respeito à ordem dos jobs, etc.).

### Detalhamento do Algoritmo Genético (`GeneticSolver`)
* **Inicialização:** População gerada a partir da solução exata, heurísticas e variações.
* **Geração:** Cada indivíduo é avaliado em paralelo. Diversidade monitorada.
* **Seleção:** Pais escolhidos por torneio, elitismo mantém os melhores.
* **Cruzamento e Mutação:** Operadores escolhidos de acordo com histórico de desempenho. Busca local pode ser aplicada aos filhos.
* **Atualização:** Melhor solução global é mantida e a população é atualizada a cada geração.
* **Convergência:** Critérios de parada envolvem tempo, ausência de melhora ou convergência populacional.

### Conclusão da Abordagem
Essa arquitetura híbrida explora o melhor dos dois mundos:
* Robustez do solver exato para soluções iniciais confiáveis.
* Potência do Algoritmo Genético e da Busca Local para exploração e intensificação do espaço de soluções.
O resultado é um pipeline flexível e eficiente para atacar instâncias desafiadoras do JSSP dentro de restrições de tempo e qualidade.
                </div>
                <div class="rendered-markdown-content mt-4"></div>
                <a href="#page-header" class="back-to-top" aria-label="Voltar ao topo da página">Voltar ao Topo &uarr;</a>
            </section>

            <section id="exemplo-grafo-disjuntivo" class="main-section scroll-mt-20 mb-10 p-6 sm:p-10" style="display: none;">
                <h2>Exemplo de Grafo Disjuntivo no JSSP</h2>
                <div class="markdown-source" style="display:none;">
Para ilustrar como o Grafo Disjuntivo representa uma solução no Job-Shop Scheduling Problem (JSSP), considere um pequeno exemplo com 2 jobs (J1, J2) e 2 máquinas (M1, M2).

**Definição do Problema:**

* **J1:** Operação 1 (J1,O1) em M1 (duração 3), Operação 2 (J1,O2) em M2 (duração 2)
* **J2:** Operação 1 (J2,O1) em M2 (duração 4), Operação 2 (J2,O2) em M1 (duração 1)

As restrições de precedência são: (J1,O1) $\rightarrow$ (J1,O2) e (J2,O1) $\rightarrow$ (J2,O2).

**Solução Candidata (Ordem das Operações nas Máquinas):**

Suponha que uma solução candidata define a seguinte ordem:

* **M1:** (J1,O1) antes de (J2,O2)
* **M2:** (J2,O1) antes de (J1,O2)

**Representação em Grafo Disjuntivo:**

O grafo teria:

* **Nós:** Source, Sink, (J1,O1), (J1,O2), (J2,O1), (J2,O2).
* **Arcos Conjuntivos:** Source $\rightarrow$ (J1,O1) [peso 0], (J1,O1) $\rightarrow$ (J1,O2) [peso 3], Source $\rightarrow$ (J2,O1) [peso 0], (J2,O1) $\rightarrow$ (J2,O2) [peso 4], (J1,O2) $\rightarrow$ Sink [peso 2], (J2,O2) $\rightarrow$ Sink [peso 1].
* **Arcos Disjuntivos Selecionados:** Para M1: (J1,O1) $\rightarrow$ (J2,O2) [peso 3]. Para M2: (J2,O1) $\rightarrow$ (J1,O2) [peso 4].

Abaixo segue o diagrama Mermaid para esta solução:
                </div>
                <div class="rendered-markdown-content mt-4"></div>
                
                <div class="mermaid">
flowchart TD
    Source["Source"] --> J1O1["J1,O1 (M1, d=3)"];
    J1O1 -- "Conjuntivo J1 (peso 3)" --> J1O2["J1,O2 (M2, d=2)"];
    J1O2 -- "Conjuntivo (peso 2)" --> Sink["Sink"];

    Source --> J2O1["J2,O1 (M2, d=4)"];
    J2O1 -- "Conjuntivo J2 (peso 4)" --> J2O2["J2,O2 (M1, d=1)"];
    J2O2 -- "Conjuntivo (peso 1)" --> Sink;

    subgraph "Máquina M1"
        J1O1 -.->|"Disjuntivo M1 (peso 3)"| J2O2;
    end

    subgraph "Máquina M2"
        J2O1 -.->|"Disjuntivo M2 (peso 4)"| J1O2;
    end

    classDef job1 fill:#BDE0FE,stroke:#A2D2FF,stroke-width:2px;
    classDef job2 fill:#FFC8DD,stroke:#FFAFCC,stroke-width:2px;
    class J1O1,J1O2 job1;
    class J2O1,J2O2 job2;
    class Source,Sink fill:#CDB4DB,stroke:#CDB4DB,stroke-width:2px;
                </div>

                <div class="markdown-source" style="display:none;">
**Cálculo do Makespan:**

O makespan desta solução é o comprimento do caminho mais longo do nó "Source" ao nó "Sink". Neste exemplo, o makespan é **6** (caminho crítico: Source $\rightarrow$ J2O1 $\rightarrow$ J1O2 $\rightarrow$ Sink).

Este exemplo demonstra como a ordem das operações (do cromossomo) define os arcos disjuntivos, permitindo calcular o makespan.
                </div>
                <div class="rendered-markdown-content mt-4"></div>
                <a href="#page-header" class="back-to-top" aria-label="Voltar ao topo da página">Voltar ao Topo &uarr;</a>
            </section>

            <section id="fluxograma" class="main-section scroll-mt-20 mb-10 p-6 sm:p-10" style="display: none;">
                <h2>Fluxograma Geral do Processo de Solução</h2>
                <div class="markdown-source" style="display:none;">
O diagrama abaixo ilustra o fluxo principal:
                </div>
                <div class="rendered-markdown-content mt-4 mb-3"></div>
                <div class="mermaid">
flowchart TD
    A["Leitura da Instância"] --> B{"Solver CP-SAT?"};
    B -- "Sim" --> C["Solução CP-SAT"];
    B -- "Não/Timeout" --> D["Heurísticas Construtivas"];
    C --> E["População Inicial GA"];
    D --> E;
    E --> F["Algoritmo Genético"];
    F -- "Loop de Gerações (UCB1, etc.)" --> F;
    F --> G{"Aplicar Busca Local (VND) nesta geração?"};
    G -- "Sim" --> H["Busca Local (VND)"];
    H -- "Refinar População/Indivíduos" --> F; 
    G -- "Não (ou GA Terminou)" --> I["Melhor Solução Encontrada"];
    I --> J["Solução Final e Validação"];
                </div>
                <a href="#page-header" class="back-to-top" aria-label="Voltar ao topo da página">Voltar ao Topo &uarr;</a>
            </section>

            <section id="resultados" class="main-section scroll-mt-20 mb-10 p-6 sm:p-10" style="display: none;">
                <h2>Resultados Obtidos</h2>
                <div class="markdown-source" style="display:none;">
A abordagem proposta foi avaliada em diversas instâncias benchmark do Job-Shop Scheduling Problem, amplamente utilizadas na literatura. A tabela a seguir apresenta o makespan final alcançado e o tempo total de execução para cada instância:
                </div>
                <div class="rendered-markdown-content mt-4"></div>
                
                <div id="markdown-table-source" style="display: none;">
| Instância | Melhor Makespan Final | Tempo Total de Execução&nbsp; |
|:----------|----------------------:|--------------------------:|
| abz5      |                  1266 |                 48,33 s   |
| abz6      |                   977 |                 25,56 s   |
| abz7      |                   701 |                382,54 s   |
| abz8      |                   993 |                 33,39 s   |
| abz9      |                   747 |                206,45 s   |
| la01      |                   666 |                 15,52 s   |
| la02      |                   672 |                 28,08 s   |
| la03      |                   606 |                 21,63 s   |
| la04      |                   611 |                 16,29 s   |
| la05      |                   593 |                 15,45 s   |
| la06      |                   926 |                 28,89 s   |
| la07      |                   890 |                 24,76 s   |
| la08      |                   863 |                 23,77 s   |
                </div>
                <div id="rendered-table-container" class="overflow-x-auto mt-6"></div>

                <div class="markdown-source" style="display:none;">
Observa-se que a abordagem foi capaz de encontrar soluções de alta qualidade para todas as instâncias, mantendo tempos de execução competitivos mesmo em casos de maior complexidade.

Esses resultados reforçam que a estratégia adotada — combinando um Algoritmo Genético robusto, soluções iniciais via CP-SAT, seleção adaptativa de operadores e busca local intensiva — é promissora para enfrentar a complexidade do JSSP, apresentando desempenho competitivo frente aos benchmarks clássicos do problema.
                </div>
                <div class="rendered-markdown-content mt-6"></div>
                <a href="#page-header" class="back-to-top" aria-label="Voltar ao topo da página">Voltar ao Topo &uarr;</a>
            </section>

            <section id="conclusao" class="main-section scroll-mt-20 mb-10 p-6 sm:p-10" style="display: none;">
                <h2>Conclusão e Principais Destaques</h2>
                <div class="markdown-source" style="display:none;">
A solução apresentada demonstra uma abordagem híbrida e robusta para o Problema de Escalonamento Job-Shop, combinando a precisão de solvers exatos para soluções iniciais com a capacidade de exploração e refinamento de meta-heurísticas avançadas. Os principais destaques incluem:

* **Geração de Soluções Iniciais de Qualidade:** Utilização do CP-SAT para fornecer um ponto de partida sólido.
* **Algoritmo Genético Especializado:** Com codificação, operadores de cruzamento e mutação adaptados ao JSSP.
* **Seleção Adaptativa de Operadores (UCB1):** Otimização dinâmica da escolha dos operadores genéticos.
* **Manipulação Eficiente de Restrições:** Uso do Grafo Disjuntivo para cálculo de makespan e validação.
* **Busca Local Intensiva (VND):** Para refinamento eficaz das soluções encontradas.

Esta combinação de técnicas visa um equilíbrio eficaz entre exploração global e exploração local, resultando numa ferramenta poderosa para encontrar cronogramas de baixo makespan.
                </div>
                <div class="rendered-markdown-content mt-4"></div>
                <a href="#page-header" class="back-to-top" aria-label="Voltar ao topo da página">Voltar ao Topo &uarr;</a>
            </section>

            <section id="limitacoes-futuros" class="main-section scroll-mt-20 mb-10 p-6 sm:p-10" style="display: none;">
                <h2>Discussão de Limitações e Trabalhos Futuros</h2>
                <div class="markdown-source" style="display:none;">
Apesar dos resultados promissores, a solução atual possui limitações. A complexidade inerente ao JSSP significa que, para instâncias muito grandes, o tempo de execução ainda pode ser um fator considerável, mesmo com as otimizações implementadas. A dependência da qualidade da solução inicial do CP-SAT também pode ser um ponto de atenção se o tempo alocado para ele for muito restrito.

Para trabalhos futuros, uma direção promissora é a exploração de técnicas de Aprendizagem por Reforço Profundo (DRL). O DRL poderia ser investigado de duas formas principais:
1.  **Como um método complementar a uma heurística existente:** Por exemplo, um agente DRL poderia aprender políticas para tomar decisões em pontos chave da construção de um cronograma ou para guiar a busca local de forma mais inteligente.
2.  **Como um método auxiliar para o Algoritmo Genético:** O DRL poderia ser usado para otimizar a seleção de operadores genéticos, ajustar dinamicamente os parâmetros do GA, ou até mesmo para gerar indivíduos iniciais mais promissores ou para guiar o processo de mutação e cruzamento de forma mais eficaz, adaptando-se às características da instância específica que está a ser resolvida pela GA.

Outras melhorias poderiam incluir a paralelização mais granular de certas etapas do Algoritmo Genético e da Busca Local, e a investigação de representações alternativas do cromossomo que possam ser mais adequadas para certos operadores genéticos.
                </div>
                <div class="rendered-markdown-content mt-4"></div>
                <a href="#page-header" class="back-to-top" aria-label="Voltar ao topo da página">Voltar ao Topo &uarr;</a>
            </section>
        </main>

        <footer class="bg-slate-100 dark:bg-slate-900 border-t border-slate-200 dark:border-slate-700/60 text-slate-500 dark:text-slate-400 py-12 text-center transition-colors duration-300">
            <div class="container-custom px-6">
                <p class="text-sm">&copy; <span id="currentYear"></span> Seu Nome/Nome do Projeto. Todos os direitos reservados.</p>
                <p class="mt-2 text-xs">Página de demonstração do trabalho sobre JSSP.</p>
            </div>
        </footer>
    </div>

    <script>
        document.getElementById('currentYear').textContent = new Date().getFullYear();

        const darkModeToggle = document.getElementById('darkModeToggle');
        const sunIcon = document.getElementById('sunIcon');
        const moonIcon = document.getElementById('moonIcon');
        const htmlElement = document.documentElement;
        
        const navLinks = document.querySelectorAll('#sidebar nav a.nav-link');
        const mainSections = document.querySelectorAll('main section.main-section');
        const activeLinkClass = 'active-nav-link';

        function renderMermaidInElement(element, isDarkTheme) {
            if (typeof mermaid !== 'undefined' && element) {
                const originalGraphDefinition = element.getAttribute('data-original-definition');
                if (originalGraphDefinition) {
                    element.removeAttribute('data-processed');
                    element.innerHTML = ''; 

                    const themeDirective = `%%{init: {'theme': '${isDarkTheme ? 'dark' : 'neutral'}'}}%%\n`;
                    const definitionTextNode = document.createTextNode(themeDirective + originalGraphDefinition);
                    element.appendChild(definitionTextNode);
                    
                    requestAnimationFrame(() => {
                        try {
                            mermaid.run({ nodes: [element] });
                        } catch (e) {
                            console.error("Erro ao renderizar Mermaid para o elemento:", element, e);
                        }
                    });
                }
            }
        }
        
        function renderAllMarkdownContent() {
            if (typeof marked !== 'undefined') {
                document.querySelectorAll('.markdown-source').forEach(sourceEl => {
                    const markdownText = sourceEl.textContent; 
                    const targetEl = sourceEl.nextElementSibling; 
                    if (targetEl && targetEl.classList.contains('rendered-markdown-content')) {
                        targetEl.innerHTML = marked.parse(markdownText);
                    }
                });
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            // Armazena definições originais do Mermaid
            document.querySelectorAll('.mermaid').forEach(el => {
                const rawDefinition = Array.from(el.childNodes)
                                        .filter(node => node.nodeType === Node.TEXT_NODE)
                                        .map(node => node.nodeValue)
                                        .join('\n')
                                        .trim();
                if (rawDefinition) {
                    el.setAttribute('data-original-definition', rawDefinition);
                }
                el.innerHTML = ''; 
            });

            // Inicializa Mermaid
            if (typeof mermaid !== 'undefined') {
                try {
                    mermaid.initialize({ startOnLoad: false }); 
                } catch (e) {
                    console.error("Erro ao inicializar Mermaid:", e);
                }
            }
            
            // Renderiza todo o conteúdo Markdown para HTML
            renderAllMarkdownContent(); 

            // Renderiza KaTeX em todo o corpo após o Markdown
            if (typeof renderMathInElement === 'function') {
                try {
                    renderMathInElement(document.body, {
                        delimiters: [
                            {left: '$$', right: '$$', display: true},
                            {left: '$', right: '$', display: false},
                            {left: '\\(', right: '\\)', display: false},
                            {left: '\\[', right: '\\]', display: true}
                        ],
                        throwOnError: false 
                    });
                } catch (e) {
                    console.error("Erro ao renderizar KaTeX na carga inicial:", e);
                }
            }


            // Aplica tema inicial
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            let initialIsDark = prefersDark;
            if (savedTheme) {
                initialIsDark = (savedTheme === 'dark');
            }
            
            if (initialIsDark) {
                htmlElement.classList.add('dark');
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
            } else {
                htmlElement.classList.remove('dark');
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
            }
            
            handleHashChange(); 
            applyTheme(initialIsDark); 

        });

        function showSection(targetId) {
            let sectionToShow = null;
            mainSections.forEach(section => {
                if (section.id === targetId) {
                    section.style.display = 'block';
                    sectionToShow = section;
                } else {
                    section.style.display = 'none';
                }
            });

            navLinks.forEach(link => {
                link.classList.toggle(activeLinkClass, link.hash === `#${targetId}`);
            });
            
            if (sectionToShow) {
                const markdownSource = sectionToShow.querySelector('.markdown-source');
                const renderedContent = sectionToShow.querySelector('.rendered-markdown-content');

                if (markdownSource && renderedContent && !renderedContent.hasChildNodes() && typeof marked !== 'undefined') {
                     renderedContent.innerHTML = marked.parse(markdownSource.textContent);
                }


                const mermaidElement = sectionToShow.querySelector('.mermaid');
                if (mermaidElement) {
                    renderMermaidInElement(mermaidElement, htmlElement.classList.contains('dark'));
                }
                if (targetId === 'resultados') {
                    renderMarkdownTable();
                }
                // Re-renderiza KaTeX para a secção que se tornou visível
                if (typeof renderMathInElement === 'function') {
                     try {
                        renderMathInElement(sectionToShow, {
                            delimiters: [
                                {left: '$$', right: '$$', display: true},
                                {left: '$', right: '$', display: false}
                            ],
                            throwOnError: false
                        });
                    } catch (e) {
                        console.error("Erro ao renderizar KaTeX em showSection:", e);
                    }
                }
            }
        }

        navLinks.forEach(link => {
            link.addEventListener('click', (event) => {
                event.preventDefault(); 
                const targetId = link.hash.substring(1);
                document.getElementById('page-header').scrollIntoView({behavior: 'auto'}); 
                showSection(targetId);
                history.pushState(null, null, `#${targetId}`);
            });
        });
        
        function handleHashChange() {
            let targetId = window.location.hash.substring(1);
            if (!targetId && mainSections.length > 0) {
                targetId = mainSections[0].id; 
                if (history.replaceState) {
                    history.replaceState(null, null, `#${targetId}`);
                }
            }
            const targetSection = document.getElementById(targetId);
            if (targetSection) {
                showSection(targetId);
            } else if (mainSections.length > 0) {
                showSection(mainSections[0].id);
                 if (history.replaceState) {
                    history.replaceState(null, null, `#${mainSections[0].id}`);
                }
            }
        }
        window.addEventListener('hashchange', handleHashChange);

        function applyTheme(isDark) {
            if (isDark) {
                htmlElement.classList.add('dark');
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
                localStorage.setItem('theme', 'dark');
            } else {
                htmlElement.classList.remove('dark');
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
                localStorage.setItem('theme', 'light');
            }

            const visibleSection = Array.from(mainSections).find(s => s.style.display === 'block');
            if (visibleSection) {
                const mermaidElement = visibleSection.querySelector('.mermaid');
                if (mermaidElement) {
                    renderMermaidInElement(mermaidElement, isDark);
                }
            }
        }

        function renderMarkdownTable() {
            const markdownTableSourceEl = document.getElementById('markdown-table-source');
            const renderedTableContainerEl = document.getElementById('rendered-table-container');

            if (markdownTableSourceEl && renderedTableContainerEl && typeof marked !== 'undefined') {
                const markdownTable = markdownTableSourceEl.textContent.trim();
                renderedTableContainerEl.innerHTML = marked.parse(markdownTable);

                const tableElement = renderedTableContainerEl.querySelector('table');
                if (tableElement) {
                    tableElement.classList.add('w-full', 'border-collapse', 'shadow-lg', 'rounded-lg', 'overflow-hidden');
                    
                    tableElement.querySelectorAll('thead th').forEach((th, index) => {
                        th.classList.add('bg-slate-100', 'dark:bg-slate-800', 'text-sm', 'font-bold', 'text-slate-600', 'dark:text-slate-300', 'uppercase', 'tracking-wider', 'p-4', 'border', 'border-slate-200', 'dark:border-slate-700');
                        if (index === 0) th.classList.add('text-center'); 
                        else th.classList.add('text-right'); 
                    });

                    tableElement.querySelectorAll('tbody td').forEach((td) => { 
                        td.classList.add('text-sm', 'text-slate-600', 'dark:text-slate-400', 'p-4', 'border', 'border-slate-200', 'dark:border-slate-700');
                        const colIndex = td.cellIndex;
                         if (colIndex === 0) td.classList.add('text-center'); 
                         else td.classList.add('text-right'); 
                    });

                    tableElement.querySelectorAll('tbody tr').forEach((tr, index) => {
                        if (index % 2 !== 0) { 
                             tr.classList.add('bg-slate-50', 'dark:bg-slate-800/60');
                        }
                        tr.addEventListener('mouseover', () => tr.classList.add('bg-sky-50', 'dark:bg-sky-900/40'));
                        tr.addEventListener('mouseout', () => tr.classList.remove('bg-sky-50', 'dark:bg-sky-900/40'));
                    });
                }
            }
        }
    </script>

</body>
</html>
